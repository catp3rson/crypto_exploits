from Crypto.Util.number import  inverse
from sage.all import EllipticCurve, GF, randint


#mapping Edward curve point to Weierstrass elliptic curve point
class EdwardsCurve:
    def __init__(self, edcurve: tuple):
        self.edcurve = edcurve
        self.montcurve = None
        self.weiercurve = None
        self.O = (0, self.edcurve[0])

    def contain_point(self, edpoint: tuple) -> bool:
        u, v = edpoint
        c, d, p = self.edcurve
        return ((u**2 + v**2) - c**2 * (1 + d * (u*v)**2)) % p == 0

    def add(self, A: tuple, B: tuple) -> tuple:
        u0, v0 = A
        u1, v1 = B

        if not (self.contain_point(A) and self.contain_point(B)):
            raise Exception("Given points do not lie on this Edwards curve")

        c, d, p = self.edcurve
        u2 = (u0 * v1 + v0 * u1) * inverse(c * (1 + d * u0 * u1 * v0 * v1), p) % p
        v2 = (v0 * v1 - u0 * u1) * inverse(c * (1 - d * u0 * u1 * v0 * v1), p) % p

        return (u2, v2)


    def mul(self, A: tuple, s: int) -> tuple:
        if not self.contain_point(A):
            raise Exception("Given point does not lie on this Edwards curve")

        Q = self.O
        
        while s:
            if (s & 1):
                Q = self.add(Q, A)
            
            s //= 2
            A = self.add(A, A)

        return Q

    def weierstrass_curve(self):
        '''
        Output: weiercurve
            weiercurve: elliptic curve in short Weierstrass form
                y^2 = x^3 + a * x^2 + b * x
        '''
        if not self.weiercurve:
            c, d, p = self.edcurve

            if c != 1:
                '''
                transform into simple Edwards curve:
                    u'^2 + v'^2 = 1 + d' * u'^2 * v'^2 (mod p)
                where   d' = c^4 * d (mod p)
                        u' = u / c (mod p)
                        v' = v / c (mod p)
                '''
                d = d * pow(c, 4, p) % p

            '''
            map the point on Edwards curve to Montgomery ellitic curve
                B*y^2 = x^3 + A*x^2 + x
            where   B = 1 / (1 - d) (mod p)
                    A = 4 / (1 - d) - 2 (mod p)
                    x = (1 + v) / (1 - v) (mod p)
                    y = (2 * (1 + v)) / (u * (1 - v)) (mod p)
            Reference: https://en.wikipedia.org/wiki/Edwards_curve#:~:text=In%20mathematics%2C%20the%20Edwards%20curves%20are%20a%20family,fields%20is%20widely%20used%20in%20elliptic%20curve%20cryptography.
            '''
            B = inverse(1 - d, p)
            A = (4 * inverse(1 - d, p) - 2) % p
            self.montcurve = (B, A, p)

            '''
            convert Montgomery form to Weierstrass form
                y'^2 = x'^3 + a * x'^2 + b * x'
            where   a = A / B (mod p)
                    b = 1 / B^2 (mod p)
                    x' = x / B (mod p)
                    y' = y / B (mod p)

            Reference: https://en.wikipedia.org/wiki/Montgomery_curve#Equivalence_with_Weierstrass_curves
            '''
            a = A * inverse(B, p) % p
            b = inverse(B**2, p)
            self.weiercurve = (a, b, p)

        return self.weiercurve


    def to_weierstrass_point(self, edpoint: tuple) -> tuple:
        if not self.contain_point(edpoint):
            raise Exception("The provided point does not lie on this Edwards curve.")


        if not self.weiercurve:
            self.weierstrass_curve()


        c, d, p = self.edcurve
        u, v = edpoint

        if c != 1:
            u = u * inverse(c, p) % p
            v = v * inverse(c, p) % p


        x = (1 + v) * inverse(1 - v, p) % p
        y = (2 * (1 + v)) * inverse(u * (1 - v), p) % p

        B = self.montcurve[0]

        x = x * inverse(B, p) % p
        y = y * inverse(B, p) % p

        a, b, p = self.weiercurve
        assert (y**2 - (x**3 + a*x**2 + b*x)) % p == 0

        return (x, y)

    

if __name__ == "__main__":
    P = (398011447251267732058427934569710020713094, 548950454294712661054528329798266699762662)
    Q = (139255151342889674616838168412769112246165, 649791718379009629228240558980851356197207)
    sP = (730393937659426993430595540476247076383331, 461597565155009635099537158476419433012710)
    tQ = (500532897653416664117493978883484252869079, 620853965501593867437705135137758828401933)
    

    c = 241270766892588524651461499096659309771090
    d = 540431316779988345188678880301417602675534
    p = 903968861315877429495243431349919213155709


    ED = EdwardsCurve((c, d, p))
    assert ED.contain_point(P) and ED.contain_point(Q) and ED.contain_point(sP) and ED.contain_point(tQ)

    weiercurve = (666183457576888778514461799596212421418684, 216420477099474068340170392405016906417100, 903968861315877429495243431349919213155709)
    Pw = (705348848352090048207756469686465258533320, 335499044993819065578722150862343997676745)


    assert ED.weierstrass_curve() == weiercurve
    assert ED.to_weierstrass_point(P) == Pw
    E = EllipticCurve(GF(p), [0, weiercurve[0], 0, weiercurve[1], 0])
    assert E(Pw)

    for _ in range(50):
        s = randint(1, 2**100)
        A = ED.mul(P, s)
        Aw = ED.to_weierstrass_point(A)
        assert E(Aw)
        assert E(Pw) * s == E(Aw)

    

    

    





        



        


    

