from sage.all import *
from Crypto.Util.number import getPrime


if __name__ == "__main__":
    '''
    Example of using Coopersmith method to factor n given sufficient of bits of p or q.
    The Coopersmith method: https://en.wikipedia.org/wiki/Coppersmith_method
    The number of bits we're required to know is about 1/4 * N.bit_length().
    '''

    p_nbits = 512       #number of bits of p
    p = getPrime(p_nbits)
    q = getPrime(512)
    n = p*q

    #leaked higher bits
    for i in range(200, 300):
        known_nbits = i
        higher = (p >> (p_nbits - known_nbits))

        R = PolynomialRing(Zmod(n), 'x', implementation="NTL")
        x = R.gen()

        '''
        f must be a monic polynomial
        '''
        f = x + (higher << (p_nbits - known_nbits))

        '''
        solve for x
        '''

        x0 = f.small_roots(beta=0.4, X=2**(p_nbits - known_nbits) - 1)

        '''
        X: the upper bound of the root (|x| < X)
        documentation of the small_roots function: https://doc.sagemath.org/html/en/reference/polynomial_rings/sage/rings/polynomial/polynomial_modn_dense_ntl.html#sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots
        note: if you reduce epsilon up to 1/512 you will be able to reduce knownbits up to 128
        '''
        if (x0):
            print(x0)


    






    
