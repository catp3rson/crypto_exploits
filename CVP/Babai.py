from sage.all import *
from random import randrange
from Crypto.Util.number import getPrime

def Babai(basis, target):
    """
    Approximately find the linear combinations of row vectors of basis 
    with integer coefficients, closest to target.
    The basis consists of vectors b0, b1, ... bn correspoding to rows 0, 1, ..., n.
    """

    #orthogonalize the basis
    t_ = target - basis.stack(target).gram_schmidt()[0].row(-1)

    #perform LLL reduction on the basis
    B_ = basis.LLL()
    
    c = B_.solve_left(t_)

    #round off the coefficents
    c_ = vector(map(round, c))

    return c_ * B_


#sanity check
if __name__ == "__main__":
    a = randrange(2**200)
    b = randrange(2**200)
    p = getPrime(512)
    x = randrange(p)
    c = (a*x + b) % p

    print(f"a: {a}")
    '''
    the basis is:
    (x + 1)     1       0
    p           0       1

    We can see that there are 2 vectors (rows) in the basis above. Moreover,
    (x+1) * a - kp ~ c
    
    or

    a * b0 + k * b1 ~ (c, 0, 0) + (small error, a, k)

    Since the error vector (small error, a, k) is small, we can use the Babai to solve CVP with
    target = (c, 0, 0).
    '''

    basis = identity_matrix(ZZ, 2).insert_row(0, vector(ZZ, [x+1, p]))
    basis = basis.transpose()
    target = vector(ZZ, [c, 0, 0])

    coeffs = Babai(basis, target)[1:]
    '''
    a = coeffs[0]
    k = coeffs[1]
    '''
    assert coeffs[0] == a
    print(f"Recovered a: {coeffs[0]}")





