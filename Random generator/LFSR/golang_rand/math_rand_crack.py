from sage.all import *
import sys
from typing import Any

class GoRandCrack:
    rngLen   = 607
    rngTap   = 273
    rngMax   = 1 << 63
    rngMask  = rngMax - 1
    int32max = (1 << 31) - 1
    
    def __init__(self) -> None:
        self.vec = None

    def next(self) -> Any:
        if self.vec is None:
            raise Exception("State is not provided.")
        self.tap -= 1
        if self.tap < 0:
            self.tap += self.rngLen
        self.feed -= 1
        if self.feed < 0:
            self.feed += self.rngLen
        x = self.vec[self.feed] + self.vec[self.tap]
        self.vec[self.feed] = x
        return x

    # state can be recovered
    # given at least 607 arbitrary outputs from rand.UInt64
    # outputs don't need to be consecutive but we need to know
    # the gaps between outputs
    # consecutive outputs guarantee that state is always recovered correctly
    # non-consecutive outputs might lead to many valid states
    # https://github.com/golang/go/blob/master/src/math/rand/rng.go
    def crack_uint64(self, outputs: list[int], gaps: list[int], verify = True) -> None:
        if len(outputs) < self.rngLen:
            print(f"Need at least {self.rngLen} enough outputs to crack RNG.", file=sys.stderr)
            sys.exit(1)

        if len(gaps) != len(outputs):
            print(f"Gaps between {len(outputs)} outputs must be provided.", file=sys.stderr)
            sys.exit(1)
        if not all([gap >= 0 for gap in gaps]):
            print("Gap cannot be negative.", file=sys.stderr)
            sys.exit(1)
            
        self.vec = []
        for i in range(self.rngLen):
            v = [0] * self.rngLen
            v[i] = 1
            self.vec.append(vector(ZZ, v))

        self.tap = 0
        self.feed = self.rngLen - self.rngTap

        M = []

        for i in range(len(outputs)):
            self.skip(gaps[i])
            M.append(self.next())

        M = matrix(Zmod(2**64), M)

        if M.change_ring(GF(2)).rank() < self.rngLen:
            print("[!] The recovered state might not be correct. You need to collect more outputs.", file=sys.stderr)

        state0 = M.solve_right(vector(Zmod(2**64), outputs))
        self.vec = list(map(int, state0))
        self.tap = 0
        self.feed = self.rngLen - self.rngTap

        # verify
        if verify:
            for i in range(len(outputs)):
                self.skip(gaps[i])
                if self.next() % (2**64) != outputs[i]:
                    raise Exception("Could not recover RNG's state.")

            self.vec = list(map(int, state0))
            self.tap = 0
            self.feed = self.rngLen - self.rngTap

    def skip(self, n):
        for _ in range(n):
            self.next()
    

if __name__ == "__main__":
    import ast
    with open("output.txt", "r") as f:
        outputs = ast.literal_eval(f.readline().split(" = ")[1].replace(" ", ","))
        outputs, extra = outputs[:1337], outputs[1337:]
        gaps = ast.literal_eval(f.readline().split(" = ")[1].replace(" ", ","))

    RC = GoRandCrack()
    RC.crack_uint64(outputs, gaps)
    RC.skip(sum(gaps) + len(outputs))

    for i in range(len(extra)):
        assert RC.next() % (2**64) == extra[i]