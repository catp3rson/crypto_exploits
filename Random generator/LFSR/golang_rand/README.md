# Cracking Golang math/rand

## Dependencies
- Sagemath: https://doc.sagemath.org/html/en/installation/index.html

## Test
```
go run main.go > output.txt && python go_rand_crack.py
```

## Example
### Cracking rand.Uint64
```Python
#!/usr/bin/env python3
from go_rand_crack import GoRandCrack

# outputs: outputs of rand.Uint64
# gaps[0]: number of times rand.Uint64 is called before outputs[0]
# gaps[i] (1 <= i < len(outputs)): number of times rand.Uint64 is called between outputs[i-1] and outputs[i]
# see main.go to see how outputs and gaps are generated
outputs: list[int] = [...]
gaps: list[int] = [...]
assert len(outputs) > 607 and len(outputs) == len(gaps)

RC = GoRandCrack()

# recover initial state of RNG
RC.crack_rng(outputs, gaps)

# call rand.Uint64 without capturing outputs
RC.skip(sum(gaps) + len(outputs))

# r is the next output of rand.Uint64 after outputs[-1]
r = RC.uint64()
print(f"Predicted output: {r}")
```

### Cracking rand.Read
```Python
#!/usr/bin/env python3
from go_rand_crack import GoRandCrack
from functools import reduce

# outputs: outputs of rand.Read
# gaps[0]: number of bytes generated using rand.Read before outputs[0]
# gaps[i] (1 <= i < len(outputs)): number of bytes generated using rand.Read between outputs[i-1] and outputs[i]
# see main.go to see how outputs and gaps are generated
outputs: list[bytes] = [...]
stream = b"".join(outputs)
assert len(stream) >= 607 * 7

RC = GoRandCrack()

# recover 56 bits of initial state of RNG
RC.crack_read(outputs, gaps)

assert RC.read(len(stream)) == stream

# r is the next 64 bytes outputted by rand.Read after outputs[-1]
r = RC.read(64)
print(f"Predicted next 64 bytes: {r}")
```