package main

import (
    "fmt"
    "math/rand"
    "math/big"
    cryptorand "crypto/rand"
	"encoding/hex"
)

func main() {
    rand.Seed(1234)
    var gaps1 [1337]int64
    var outputs1 [1337+64]uint64
    maxGap := big.NewInt(13)     // set to 1 for consecutive outputs
    for i := 0; i < 1337; i += 1 {
        gap, err := cryptorand.Int(cryptorand.Reader, maxGap)
        if err != nil {
            panic(err)
        }
        gaps1[i] = gap.Int64()
        for j := int64(0); j < gaps1[i]; j += 1 {
            rand.Uint64()
        }
        outputs1[i] = rand.Uint64()
    }
    // extra outputs to verify exploit
    for i := 1337; i < 1337+64; i += 1 {
        outputs1[i] = rand.Uint64()
    }
    fmt.Printf("outputs of Uint64 = %v\n", outputs1)
    fmt.Printf("gaps of Uint64 = %v\n", gaps1)

    rand.Seed(1234)
    var gaps2 [266]int64
    var outputs2 [266+64]string
    // stream of bytes to feed to cracker
    for i := 0; i < 266; i += 1 {
		r := make([]byte, 16)
		rand.Read(r)
        outputs2[i] = hex.EncodeToString(r)
    }
    // extra outputs to verify exploit
    for i := 266; i < 266+64; i += 1 {
		r := make([]byte, 16)
        rand.Read(r)
        outputs2[i] = hex.EncodeToString(r)
    }
    fmt.Printf("outputs of Read = %v\n", outputs2)
    fmt.Printf("gaps of Read = %v\n", gaps2)
}