from sage.all import *
import sys
from typing import Any
from functools import reduce

class GoRandCrack:
    rngLen   = 607
    rngTap   = 273
    rngMax   = 1 << 63
    rngMask  = rngMax - 1
    int32max = (1 << 31) - 1
    
    def __init__(self) -> None:
        self.vec = None
        self.nbits = 0
        self.readPos = 0
        self.readVal = None

    def next(self) -> Any:
        if self.vec is None:
            raise Exception("State is not provided.")
        self.tap -= 1
        if self.tap < 0:
            self.tap += self.rngLen
        self.feed -= 1
        if self.feed < 0:
            self.feed += self.rngLen
        x = self.vec[self.feed] + self.vec[self.tap]
        self.vec[self.feed] = x
        return x

    def crack_rng(self, outputs: list[int], gaps: list[int] = None, nbits: int = 64, verify = True) -> None:
        """
        Recover `nbits` bits of RNG's state based on a series of outputs of 
        `nbits` MSB outputted by rand.Uint64. This implementation supports
        both consecutive and non-consecutive outputs.
        
        outputs: outputs of rand.Uint64
        gaps[0]: number of times rand.Uint64 is called before outputs[0]
        gaps[i] (1 <= i < len(outputs)): number of times rand.Uint64 is called between outputs[i-1] and outputs[i]
        """
        if len(outputs) < self.rngLen:
            print(f"Need at least {self.rngLen} enough outputs to crack RNG.", file=sys.stderr)
            sys.exit(1)

        if gaps is None:    # consecutive outputs
            gaps = [0] * len(outputs)
        else:
            if len(gaps) != len(outputs):
                print(f"Gaps between {len(outputs)} outputs must be provided.", file=sys.stderr)
                sys.exit(1)
            if not all([gap >= 0 for gap in gaps]):
                print("Gap cannot be negative.", file=sys.stderr)
                sys.exit(1)
        
        mod = 2**nbits
        Zn = Zmod(mod)
        self.vec = []
        for i in range(self.rngLen):
            v = [0] * self.rngLen
            v[i] = 1
            self.vec.append(vector(Zn, v))

        self.tap = 0
        self.feed = self.rngLen - self.rngTap

        M = []

        for i in range(len(outputs)):
            self.skip(gaps[i])
            M.append(self.next())

        M = matrix(Zn, M)

        if M.change_ring(GF(2)).rank() < self.rngLen:
            print("[!] The recovered state might not be correct. You need to collect more outputs.", file=sys.stderr)

        try:
            state0 = M.solve_right(vector(Zn, outputs))
        except:
            raise Exception("Cannot solve for state. Make sure that your inputs are correct.")

        self.vec = list(map(Zn, state0))
        self.tap = 0
        self.feed = self.rngLen - self.rngTap

        # verify
        if verify:
            for i in range(len(outputs)):
                self.skip(gaps[i])
                if self.next() % mod != outputs[i]:
                    raise Exception("Could not recover RNG's state.")

            self.vec = list(map(Zn, state0))
            self.tap = 0
            self.feed = self.rngLen - self.rngTap

        print(f"Successfully recovered {'all' if nbits == 64 else nbits} bits of RNG's state.")
        self.nbits = nbits

    def crack_read(self, stream: bytes, priorNumBytes: int = 0) -> None:
        """
        Recover 56 bits of RNG's state based on a stream of bytes generated
        by rand.Read. Current implementation only supports consecutive stream.
        
        stream: consecutive stream of bytes generated by calling rand.Read.
        All bytes of stream do not need to be generated at once. They can be
        generated by multiple calls of rand.Read, but these calls MUST be 
        consecutive.
        priorNumBytes: number of bytes generated by rand.Read before stream
        is generated
        """
        remainBytes = (7 - (priorNumBytes % 7)) % 7

        if (len(stream) - remainBytes) // 7 < self.rngLen:
            raise Exception("Not enough bytes to recover state.")

        # discard the remaining bytes of previous readVal
        stream = stream[remainBytes:]
        outputs_uint56 = []
        for i in range(0, (len(stream)//7) * 7, 7):
            outputs_uint56.append(int.from_bytes(stream[i:i+7], "little"))
        self.crack_rng(outputs_uint56, nbits=56)

    def uint64(self) -> int:
        if self.nbits < 64:
            raise Exception("Number of recovered bits is not enough.")
        return int(self.next())

    def int63(self) -> int:
        if self.nbits < 63:
            raise Exception("Number of recovered bits is not enough.")
        return int(self.next()) & self.rngMask

    def read(self, nbytes: int) -> bytes:
        if self.nbits < 56:
            raise Exception("Number of recovered bits is not enough.")
        ret = [0] * nbytes
        pos = self.readPos
        val = self.readVal
        for i in range(nbytes):
            if pos == 0:
                val = int(self.next()) & (2**56 - 1)
                pos = 7
            ret[i] = val % 256
            val >>= 8
            pos -= 1
        self.readPos = pos
        self.readVal = val
        return bytes(ret)

    def skip(self, n) -> None:
        for _ in range(n):
            self.next()


if __name__ == "__main__":
    import ast

    with open("output.txt", "r") as f:
        outputs1 = ast.literal_eval(f.readline().split(" = ")[1].replace(" ", ","))
        outputs1, extra1 = outputs1[:1337], outputs1[1337:]
        gaps1 = ast.literal_eval(f.readline().split(" = ")[1].replace(" ", ","))

        tmp = f.readline().split(" = ")[1].strip("[]\n").split()
        outputs2 = [bytes.fromhex(s) for s in tmp]
        outputs2, extra2 = outputs2[:607], outputs2[607:]
        gaps2 = ast.literal_eval(f.readline().split(" = ")[1].replace(" ", ","))

    RC = GoRandCrack()
    RC.crack_rng(outputs1, gaps1)
    RC.skip(sum(gaps1) + len(outputs1))
    for i in range(len(extra1)):
        assert RC.uint64() == extra1[i]
    print("Cracking rand.Uint64 succeeded.")
        
    RC = GoRandCrack()
    stream = b"".join(outputs2)
    extraStream = b"".join(extra2)
    RC.crack_read(stream)
    assert RC.read(len(stream)) == stream
    assert RC.read(len(extraStream)) == extraStream
    print("Cracking rand.Read succeeded.")
