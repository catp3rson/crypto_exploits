from functools import reduce
from Crypto.Util.number import *
import random
from sage.all import CRT

"""
    Isomorphism from F_{p^e}* -> F_{p^{e-1}}+
    k: element
    p: prime
    e: exponent of prime power
    Based on https://math.stackexchange.com/questions/1863037/discrete-logarithm-modulo-powers-of-a-small-prime
"""

def isomorph(k, p, e):
    t1 = pow(p, e-1)
    res = (pow(k, (p-1) * t1, pow(p, 2*e - 1)) // (t1 * p)) % t1
    return res

def product(l):
    return reduce(lambda x, y: x*y, l, 1)

def main():
    # discrete log modulo p^e
    p = getPrime(256)
    e = random.randint(1, 10)
    N = pow(p, e)

    g = random.randint(2, N-1)
    while GCD(g, p) != 1:
        g = random.randint(2, N-1)

    m = random.randint(0, pow(p, e-1) - 1)
    gm = pow(g, m, N)
    A = isomorph(gm, p, e)
    B = isomorph(g, p, e)
    d_log = A * inverse(B, pow(p, e-1)) % pow(p, e-1)
    assert m == d_log


    # discrete log modulo product of prime powers
    primes = [getPrime(256) for _ in range(16)]
    exps = [random.randint(1, 10) for _ in range(16)]
    N = product([p**e for p, e in zip(primes, exps)])
    t1 = product(primes)
    t2 = product([p**(e-1) for p, e in zip(primes, exps)])
    
    g = random.randint(2, N-1)
    while GCD(g, t1) != 1:
        g = random.randint(2, N-1)

    m = random.randint(0, t2 - 1)
    gm = pow(g, m, N)
    residues = []

    for p, e in zip(primes, exps):
        A = isomorph(gm % pow(p, e), p, e)
        B = isomorph(g % pow(p, e), p, e)
        d_log = A * inverse(B, pow(p, e-1)) % pow(p, e-1)
        residues.append(d_log)

    recovered_m = CRT(residues, [pow(p, e-1) for p, e in zip(primes, exps)])
    assert recovered_m == m

main()
    
