from hashlib import sha256
import multiprocessing as mp
import random
import os



def worker(child_index, challenge_string, hash_function, pre_image):
    print(f"[+] Child process no.{child_index} started.")
    s = os.urandom(len(pre_image) - 1)

    while True:
        h = hash_function(s)
        if all([((challenge_string[i] == "x") or (h[i] == challenge_string[i])) for i in range(len(h))]):
            pre_image[0] = 1

            for i in range(1, len(pre_image)):
                pre_image[i] = s[i-1]

            print("[*] Found suitable pre-image.")
            print(f"[-] Child process no.{child_index} terminated.")
            break

        else:
            s = s[1:] + bytes([random.randint(0,255)])

        if pre_image[0]:
            print(f"[-] Child process no.{child_index} terminated.")
            break

    


'''
PoW solver with hash function of choice
'''
def PoW_solver(challenge_string, hash_function, pre_image_len, num_process=None):
    '''
    Input:
        challenge_string [str]: the hex digest required by the PoW
        place_holder [str]: the placeholder character that's used in the challenge_string. It must not be a hexdigit.
        hash_function [Function]: Hash function used by the PoW. 
            Its input must be bytes and its output must be the hex digest of the input.

    Output:
        pre_image: the string that hashes to the same format as the challenge_string
    '''


    #calculate number of child processes
    if not num_process:
        num_cpu = mp.cpu_count()
        num_process = num_cpu // 4



    print(f"[*] Spawning {num_process} child processes.")


    pre_image = mp.Array('B', pre_image_len + 1)


    #create child processes
    pool = [mp.Process(target=worker, args=(i, challenge_string, hash_function, pre_image)) for i in range(num_process)]


    for p in pool:
        p.start()

    for p in pool:
        p.join()

    
    pre_image = bytes(pre_image[1:])

    h = hash_function(pre_image)
    assert all([((challenge_string[i] == "x") or (h[i] == challenge_string[i])) for i in range(len(h))])

    return pre_image


def sha256_wrapper(bytestr):
    return sha256(bytestr).hexdigest()


if __name__ == "__main__":
    #test with suffix
    challenge_string = sha256_wrapper(os.urandom(4))
    suffix_len = 5
    challenge_string = "x" *  (len(challenge_string) - suffix_len) + challenge_string[-suffix_len:]

    pre_image = PoW_solver(
        challenge_string=challenge_string,
        hash_function=sha256_wrapper,
        pre_image_len=32,
        num_process=4
    )

    assert sha256_wrapper(pre_image)[-suffix_len:] == challenge_string[-suffix_len:]

    #test with prefix
    challenge_string = sha256_wrapper(os.urandom(4))
    prefix_len = 5
    challenge_string = challenge_string[:prefix_len] + "x" *  (len(challenge_string) - prefix_len)

    pre_image = PoW_solver(
        challenge_string=challenge_string,
        hash_function=sha256_wrapper,
        pre_image_len=32,
        num_process=4
    )

    assert sha256_wrapper(pre_image)[:prefix_len] == challenge_string[:prefix_len]


    #test with middle bytes
    challenge_string = sha256_wrapper(os.urandom(4))
    middle_len = 5
    pos_range = (5,10)
    challenge_string = "x" * pos_range[0] + challenge_string[pos_range[0]: pos_range[1]] + "x" * (len(challenge_string) - pos_range[1])


    pre_image = PoW_solver(
        challenge_string=challenge_string,
        hash_function=sha256_wrapper,
        pre_image_len=32,
        num_process=4
    )

    assert sha256_wrapper(pre_image)[pos_range[0]: pos_range[1]] == challenge_string[pos_range[0]: pos_range[1]]




    