from sage.all import factor,log, crt, GF, randint
from Crypto.Util.number import getPrime, isPrime
import random

MAX_TABLE_SIZE = 2**22
MAX_STEP_SIZE = 2**24
MIN_STEP_SIZE = 2**10

def bsgs(a, base, identity=None, group_size=None, addmul=None, mulexp=None):
    if not (group_size and identity and addmul and mulexp):
        raise Exception("Plese specify the group size + identity element + addmul + mulexp")

    if group_size > MAX_TABLE_SIZE * MAX_STEP_SIZE:
        raise ValueError("Group size is too big")


    if group_size < MIN_STEP_SIZE:
        for i in range(group_size):
            if mulexp(base, i) == a:
                return i


    table = dict()
    step_size = 2**(int(log(group_size, 2)) // 2)


    #build table
    tmp = step = mulexp(base, step_size)
    for i in range(step_size, group_size+1, step_size):
        table[tmp] = i
        tmp = addmul(tmp, step)


    tmp = a
    for i in range(step_size):
        if tmp in table:
            return table[tmp] if i == 0 else ((table[tmp] - step_size) + (step_size - i))

        tmp = addmul(tmp, base)
        

    #examine the last chunk
    k = group_size // step_size
    tmp = mulexp(base, k*step_size)

    for i in range(k * step_size, group_size, 1):
        if tmp == a:
            return i

        tmp = addmul(tmp, base)


    print(group_size)
    raise ValueError("Cannot find discrete log using BSGS")
        



def pohlig_hellman(a, base, order=None, identity=None, addmul=None, mulexp=None):
    if not (order and identity and addmul and mulexp):
        raise Exception("Plese specify the order + identity + addmul + mulexp")

    factors = factor(order)
    residues = []
    moduli = []

    for f in factors:
        p = f[0]
        exp = f[1]

        y = mulexp(base, order // (p**exp))
        h = mulexp(a, order // (p**exp))

        residues.append(bsgs(h, base=y, identity=identity, group_size=p**exp, addmul=addmul, mulexp=mulexp))
        moduli.append(p**exp)


    return int(crt(residues, moduli))

def mul(a, b):
    return (a * b) % p

def exp(a,e):
    return pow(a, e, p)


if __name__ == "__main__":
    #test with small prime
    for _ in range(20):
        p = getPrime(28)
        base = randint(1,p-1)
        order = GF(p)(base).multiplicative_order()
        x = randint(1, order)
        a = pow(base, x, p)
        factors = factor(order)
        x_ = pohlig_hellman(a, base=base, identity=1, order=order, addmul=mul, mulexp=exp)

        assert x == x_


    # #test with big smooth prime
    # p_ = 2**3 * 7
    # primes = [getPrime(28) for _ in range(20)]
    # for prime in primes:
    #     p_ *= prime

    # while True:
    #     if isPrime(p_ + 1):
    #         print("Found smooth prime.")
    #         break
        
    #     tmp = random.choice(primes)
    #     primes.remove(tmp)
    #     p //= tmp

    #     new_prime = getPrime(28)
    #     p_ *= new_prime
    #     primes.append(new_prime)


    # p = p_ + 1
    # base = randint(1, p-1)
    # order = GF(p)(base).multiplicative_order()
    # x = randint(1, order)
    # a = pow(base, x, p)
    # x_ = pohlig_hellman(a, base=base, identity=1, order=order, addmul=mul, mulexp=exp)

    # assert x == x_





        

    



    







        
